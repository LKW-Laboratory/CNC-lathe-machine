<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Talking Character â€“ CNC Lathe (front lock + yaw offset)</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .btn { position:absolute; top:16px; left:16px; z-index:10; padding:10px 16px; border:none; border-radius:10px; margin-right:8px; background:#fff; color:#111; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.25); }
    #muteButton { left:140px; }
    #hint { position:absolute; bottom:16px; left:16px; color:#bbb; font-family:system-ui, sans-serif; font-size:12px }
    #loading { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#fff; font-family:system-ui; background:rgba(0,0,0,.6) }
  </style>
</head>
<body>
  <div id="loading">Loading modelâ€¦</div>
  <button id="audioButton" class="btn">ðŸ”Š Play Audio</button>
  <button id="muteButton" class="btn">ðŸ”ˆ Mute</button>
  <div id="hint">drag = orbit Â· wheel = zoom</div>
  <canvas id="renderCanvas"></canvas>
  <audio id="voice" src="CNC Lathe audio.mp3" preload="auto"></audio>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true, doNotHandleContextLost:true });

    let scene, root, idleGroup=null, talkGroups=[];
    const CAMERA_BACKOFF = 2.05;   // farther back
    const BETA_UP_TILT   = 0.06;   // slight up tilt
    const YAW_OFFSET     = Math.PI/2;  // <<< if you still see a profile/back, try -Math.PI/2

    function stopAllAnimations(sc){ (sc.animationGroups||[]).forEach(g=>{ try{ g.stop(); }catch(e){} }); sc.stopAllAnimations(); }

    function normalizeUpAxis(mesh){
      const bb = mesh.getHierarchyBoundingVectors(true);
      const sz = bb.max.subtract(bb.min);
      if (sz.z > sz.y * 1.5) mesh.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.LOCAL); // Z-up -> Y-up
      const bb2 = mesh.getHierarchyBoundingVectors(true);
      if (bb2.max.y < 0) mesh.rotate(BABYLON.Axis.Z, Math.PI, BABYLON.Space.LOCAL);       // upside-down guard
    }

    // Pick Y-rotation with smallest depth (front-ish), then apply a fixed yaw offset to force true front
    function chooseFrontAndOffset(mesh){
      const candidates = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
      let best = 0, bestDepth = Infinity;
      for (const a of candidates){
        mesh.rotation.y = a;
        const bb = mesh.getHierarchyBoundingVectors(true);
        const depth = bb.max.z - bb.min.z;
        if (depth < bestDepth){ bestDepth = depth; best = a; }
      }
      mesh.rotation.y = best + YAW_OFFSET; // force turn from profile to actual front
      return mesh.rotation.y;
    }

    function centerAndScale(mesh){
      const bb = mesh.getHierarchyBoundingVectors(true);
      const c  = bb.min.add(bb.max).scale(0.5);
      mesh.position = mesh.position.subtract(c);
      const size = bb.max.subtract(bb.min);
      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0){ const s = 2.0 / maxDim; mesh.scaling = new BABYLON.Vector3(s, s, s); }
    }

    function placeCameraFromFacing(camera, mesh, facingAngle){
      const bb = mesh.getHierarchyBoundingVectors(true);
      const center = bb.min.add(bb.max).scale(0.5);
      const size   = bb.max.subtract(bb.min);
      const maxDim = Math.max(size.x, size.y, size.z);

      const forwardLocal = new BABYLON.Vector3(0,0,1);
      const forward = BABYLON.Vector3.TransformNormal(forwardLocal, BABYLON.Matrix.RotationY(facingAngle));

      const dist = Math.max(2.2, maxDim * CAMERA_BACKOFF);
      const camPos = center.subtract(forward.scale(dist));
      camPos.y = center.y + maxDim * 0.02;

      camera.setTarget(center);
      camera.setPosition(camPos);
      camera.alpha = Math.atan2(-forward.x, -forward.z);
      camera.beta  = Math.PI/2 + BETA_UP_TILT;

      camera.lowerBetaLimit = Math.PI/2 - 0.1;
      camera.upperBetaLimit = Math.PI/2 + 0.55;
      camera.lowerRadiusLimit = maxDim * 0.8;
      camera.upperRadiusLimit = maxDim * 5;
    }

    async function createScene(){
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0,0,0,1);

      const camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI/2, 3.0, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);
      const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
      light.intensity = 1.25;

      const result = await BABYLON.SceneLoader.ImportMeshAsync("", "./", "CNC LATHE machine.glb", scene);
      root = result.meshes[0];
      result.meshes.forEach(m => { if (m.rotationQuaternion) m.rotationQuaternion = null; });

      normalizeUpAxis(root);
      stopAllAnimations(scene);
      const facing = chooseFrontAndOffset(root);  // << front + enforced yaw offset
      centerAndScale(root);
      placeCameraFromFacing(camera, root, facing);

      const groups = scene.animationGroups || [];
      const has = (g, arr) => arr.some(w => g.name.toLowerCase().includes(w));
      idleGroup  = groups.find(g => has(g, ["idle","stand","breath","breathe","rest"]));
      talkGroups = groups.filter(g => has(g, ["wolf3d","viseme","lip","phoneme","talk","speak","mouth"]));
      if (talkGroups.length === 0) talkGroups = groups.filter(g => g !== idleGroup);
      if (idleGroup) idleGroup.start(true, 1.0, idleGroup.from, idleGroup.to, true);

      document.getElementById("loading").style.display = "none";
      return scene;
    }

    createScene().then(() => engine.runRenderLoop(() => scene && scene.render()));
    window.addEventListener("resize", () => engine.resize());

    // audio / animation
    const audio = document.getElementById("voice");
    const playBtn = document.getElementById("audioButton");
    const muteBtn = document.getElementById("muteButton");

    function startTalking(){ if (idleGroup) idleGroup.stop(); talkGroups.forEach(g => { try{ g.stop(); }catch(e){} g.start(false, 1.0, g.from, g.to, false); }); }
    function stopTalking(){ talkGroups.forEach(g => g.stop()); if (idleGroup) idleGroup.start(true, 1.0, idleGroup.from, idleGroup.to, true); }

    playBtn.addEventListener("click", async () => { try { audio.currentTime = 0; await audio.play(); } catch(e) {} startTalking(); });
    audio.addEventListener("ended", stopTalking);

    let muted=false;
    muteBtn.addEventListener("click", ()=>{ muted=!muted; audio.muted=muted; muteBtn.textContent = muted ? "ðŸ”‡ Unmute" : "ðŸ”ˆ Mute"; });
  </script>
</body>
</html>
